#Best:
import math

class Solution:
    def isPalindrome(self, s: str) -> bool:
        s = "".join(filter(lambda c: 'a' <= c <= 'z' or '0' <= c <= '9', s.lower()))
        
        for i in range(len(s) // 2):
            if s[i] != s[-i - 1]:
                return False
        
        return True
        
        
#Number Version:
def isPalindrome(self, x):
    if x > 0:
        temp = x
        rev_int_elements = []
        while temp > 0:
            digit = temp % 10
            rev_int_elements.append(digit)
            temp = temp // 10
        org_int_elements = rev_int_elements[::-1]
        return rev_int_elements == org_int_elements
    elif x == 0:
        return True
    else:
        return False

#Variant 1:


class Solution:
    def isPalindrome(self, s: str) -> bool:
        s = "".join(filter(lambda c: 'z' >= c >= 'a' or '9' >= c >= '0', s.lower()))
        
        if len(s) == 1:
            return True
        
        first = s[:int(len(s) / 2.0)]
        second = s[int(math.ceil(len(s) / 2.0)):][::-1]
        
        return first == second
        



#Variant 2:
        
        

class Solution:
    def isPalindrome(self, s: str) -> bool:
        s = "".join(filter(lambda c: 'a' <= c <= 'z' or '0' <= c <= '9', s.lower()))
        
        if len(s) == 1:
            return True
        
        first = s[:int(len(s) / 2.0)]
        second = s[len(s) : int(math.ceil(len(s) / 2.0)) - 1 : -1]
        
        return first == second
        

#Variant 3:        

class Solution:
    def isPalindrome(self, s: str) -> bool:
        s = "".join(filter(lambda c: 'z' >= c >= 'a' or '9' >= c >= '0', s.lower()))
        return s[:int(len(s) / 2.0)] == s[int(math.ceil(len(s) / 2.0)):][::-1] if len(s) != 1 else True
